/**
 * This Firestore Security Ruleset enforces a strict user-ownership model, designed for
 * applications where user data is private and should never be accessible by other users.
 *
 * Core Philosophy:
 * The security model is centered on "path-based ownership." All user-specific data is
 * stored in subcollections under a document uniquely identified by that user's UID.
 * This ensures that authorization can be determined simply by comparing the requesting
 * user's UID (`request.auth.uid`) with the user ID present in the document path.
 *
 * Data Structure:
 * All user-owned data is nested hierarchically under the `/users/{userId}` path. This
 * top-level document stores the user's profile, and subsequent private data, such as
 * subscriptions and analytics, are stored in dedicated subcollections within that user's
 * document tree (e.g., `/users/{userId}/subscriptions/{subscriptionId}`).
 *
 * Key Security Decisions:
 * - User Data Isolation: A user can only access documents within their own data tree
 *   (i.e., where the `{userId}` in the path matches their authenticated UID).
 * - No User Enumeration: The ability to list documents in the top-level `/users`
 *   collection is explicitly disabled to prevent malicious actors from discovering
 *   the application's user base.
 * - Relational Integrity: On creation, documents must contain an internal `id` or
 *   `userId` field that matches the `{userId}` in the path. This field is enforced
 *   as immutable on updates to prevent re-linking documents to different owners.
 * - Default Deny: All operations are denied by default. Access is only granted through
 *   explicit `allow` statements.
 *
 * Denormalization for Authorization:
 * The data structure inherently uses denormalization for authorization. By placing
 * all user data under a path containing their UID (`/users/{userId}`), we avoid
 * slow and costly `get()` calls to other documents for ownership verification.
 * This makes the rules fast, scalable, and easy to audit.
 *
 * Structural Segregation:
 * The data model uses structural segregation to separate each user's data into its
 * own document tree. This makes security rules for listing documents simple and safe,
 * as a query against a user's subcollection (e.g., `/users/abc/subscriptions`) can
 * never accidentally leak data belonging to another user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's ID matches the provided userId from the path.
     * This is the fundamental check for all user-owned data.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies ownership for an existing document. Used for update and delete operations
     * to ensure the document exists before the operation is attempted.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a new user document has an `id` field that matches the document's ID
     * in the path, ensuring relational integrity upon creation.
     */
    function isCreatingOwnUserDocument(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces immutability of the user `id` field during an update.
     */
    function isUpdatingOwnUserDocument() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a new document in a user's subcollection has a `userId` field
     * that matches the owner's ID from the path.
     */
    function isCreatingChildDocument(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the `userId` field in a subcollection document during an update.
     */
    function isUpdatingChildDocument() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own user document.
     * @deny (list) A user cannot list all other users in the system.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isCreatingOwnUserDocument(userId);
      allow update: if isExistingOwner(userId) && isUpdatingOwnUserDocument();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's subscription records.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (create) An authenticated user can create a subscription document for themselves.
     * @deny (get) An authenticated user cannot access subscriptions belonging to another user.
     * @principle Enforces document ownership for all operations within a user-specific subcollection.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingChildDocument(userId);
      allow update: if isExistingOwner(userId) && isUpdatingChildDocument();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's email analytics data.
     * @path /users/{userId}/email_analytics/{emailAnalyticsId}
     * @allow (list) An authenticated user can list their own email analytics records.
     * @deny (update) An authenticated user cannot update analytics data belonging to another user.
     * @principle Enforces document ownership and validates relational integrity between parent and child documents.
     */
    match /users/{userId}/email_analytics/{emailAnalyticsId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingChildDocument(userId);
      allow update: if isExistingOwner(userId) && isUpdatingChildDocument();
      allow delete: if isExistingOwner(userId);
    }
  }
}